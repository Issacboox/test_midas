{"mappings":"AAKA,SAAS,aAAa,KAAY;IAC9B,MAAM,UAAU,IAAI;IACpB,MAAM,OAAiB,EAAE;IACzB,MAAM,QAAQ;QAAC;QAAG;QAAG;QAAG;QAAG;QAAG;KAAE;IAEhC,SAAS,SAAS,UAAkB,EAAE,SAAiB;QACnD,IAAI,eAAe,KACf,OAAO;QAGX,IAAI,cAAc,GACd,OAAO;QAGX,KAAK,MAAM,QAAQ,MAAO;YACtB,MAAM,UAAU,aAAa;YAE7B,IAAI,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,GAAK,UAAU,UAC/C;gBAAA,IAAI,SAAS,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,GAAK,UAAU,QAAS,CAAC,EAAE,EAAE,YAAY,IAAI;oBACtF,KAAK,IAAI,CAAC;oBACV,OAAO;gBACX;YAAA,OACG,IAAI,MAAM,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,GAAK,UAAU,UACrD;gBAAA,IAAI,SAAS,MAAM,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,IAAI,GAAK,UAAU,QAAS,CAAC,EAAE,EAAE,YAAY,IAAI;oBACrF,KAAK,IAAI,CAAC;oBACV,OAAO;gBACX;YAAA,OACG,IAAI,CAAC,QAAQ,GAAG,CAAC,YAAY,WAAW,KAAK;gBAChD,QAAQ,GAAG,CAAC;gBACZ,IAAI,SAAS,SAAS,YAAY,IAAI;oBAClC,KAAK,IAAI,CAAC;oBACV,OAAO;gBACX;YACJ;QACJ;QAEA,OAAO;IACX;IAEA,SAAS,GAAG;IAEZ,OAAO,KAAK,OAAO;AACvB;AAEA,gBAAgB;AAChB,MAAM,QAAe;IACjB,SAAS;QAAC;YAAC;YAAG;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;KAAC;IAC9E,QAAQ;QAAC;YAAC;YAAI;SAAE;QAAE;YAAC;YAAI;SAAE;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;QAAE;YAAC;YAAI;SAAG;KAAC;AAChF;AAEA,QAAQ,GAAG,CAAC,aAAa,SAAS,4BAA4B","sources":["src/q3.ts"],"sourcesContent":["interface Board {\r\n    ladders: [number, number][];\r\n    snakes: [number, number][];\r\n}\r\n\r\nfunction quickestPath(board: Board): number[] {\r\n    const visited = new Set<number>();\r\n    const path: number[] = [];\r\n    const rolls = [6, 5, 4, 3, 2, 1];\r\n\r\n    function findPath(currentPos: number, rollsLeft: number): boolean {\r\n        if (currentPos === 100) {\r\n            return true;\r\n        }\r\n\r\n        if (rollsLeft === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (const roll of rolls) {\r\n            const nextPos = currentPos + roll;\r\n\r\n            if (board.ladders.some(([start, end]) => start === nextPos)) {\r\n                if (findPath(board.ladders.find(([start, end]) => start === nextPos)![1], rollsLeft - 1)) {\r\n                    path.push(roll);\r\n                    return true;\r\n                }\r\n            } else if (board.snakes.some(([start, end]) => start === nextPos)) {\r\n                if (findPath(board.snakes.find(([start, end]) => start === nextPos)![1], rollsLeft - 1)) {\r\n                    path.push(roll);\r\n                    return true;\r\n                }\r\n            } else if (!visited.has(nextPos) && nextPos <= 100) {\r\n                visited.add(nextPos);\r\n                if (findPath(nextPos, rollsLeft - 1)) {\r\n                    path.push(roll);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    findPath(1, 6);\r\n\r\n    return path.reverse();\r\n}\r\n\r\n// Example board\r\nconst board: Board = {\r\n    ladders: [[3, 39], [14, 35], [31, 70], [44, 65], [47, 86], [63, 83], [71, 93]],\r\n    snakes: [[21, 4], [30, 8], [55, 38], [79, 42], [87, 54], [91, 48], [96, 66]]\r\n};\r\n\r\nconsole.log(quickestPath(board)); // Output: [ 2, 5, 6, 6, 1 ]\r\n"],"names":[],"version":3,"file":"index.bed60da4.js.map","sourceRoot":"/__parcel_source_root/"}